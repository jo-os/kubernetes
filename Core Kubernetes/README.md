# Почему появился Kubernetes

**Kubernetes** – это платформа с открытым исходным кодом для размещения контейнеров и определения прикладных API для управления облачной семантикой обеспечения этих контейнеров хранилищами данных, сетевыми услугами, поддержкой безопасности и другими ре- сурсами. Kubernetes обеспечивает непрерывную синхронизацию все- го пространства состояний ваших приложений, в том числе способов доступа к ним из внешнего мира.

**Основыне теримины:**
- CNI (Container Networking Interface) и CSI (Container Storage Inter- face) – сетевой интерфейс контейнеров и интерфейс хранилища для контейнеров соответственно; позволяют подключать к се- тям и хранилищам модули Pod (с контейнерами), работающие в Kubernetes;
- контейнер (Container) – образ Docker или OCI (Open Container Ini- tiative), который обычно запускает приложение;
- плоскость управления (Control plane) – мозг кластера Kubernetes, осуществляющий планирование контейнеров и управляющий всеми объектами Kubernetes (которые иногда называют мастер- объектами);
- набор демонов (DaemonSet) – аналог развертывания (Deployment), но выполняется на каждом узле кластера;
- развертывание (Deployment) – набор модулей, которыми управ- ляет Kubernetes;
- kubectl – инструмент командной строки для взаимодействия с панелью управления Kubernetes;
- kubelet – агент Kubernetes, работающий на узлах кластера. Обе- спечивает поддержку плоскости управления;
- узел (Node) – машина, на которой запущен процесс kubelet;
- OCI (Open Container Initiative) – общий формат образа для созда- ния выполняемых автономных приложений. Также называется образами Docker;
- Pod (модуль) – объект Kubernetes, инкапсулирующий действую- щий контейнер.

Kubernetes дает возможность централизовать управление пространством состояний всех приложений с использованием одного удобного инструмента: kubectl – клиента командной строки, выполняющего вызовы REST API к серверу Kubernetes API.

Kubernetes использует привилегированный контейнер в среде Linux, он может управлять правилами iptables для организации маршрутизации трафика к приложениям, что, собственно, и делает прокси-сервер Kubernetes Service - kube-proxy. Контейнеры оказываются фундаментальным примитивом и для запуска приложений, и для управления инфраструктурой, которые запускают сервисы, необходимые приложениям (специализированные хранилища или брандмауэры с определенными настройками), и, что особенно важно, сами приложения. Kubernetes практически бесспорно считается современным стандартом для организации и запуска контейнеров в любом облачном окружении, на сервере или в центре обработки данных.

**Контейнеры и образы**

Docker можно рассматривать как способ запуска контейнеров, где контейнер – это работающий образ OCI. Спецификация OCI – это стандартный способ определения образа, который может быть запущен такой программой, как Docker, и в конечном счете представляет собой архив с различными слоями. Контейнеры добавляют слой изоляции, устраняющий необходимость управления библиотеками на сервере или предварительной загрузки инфраструктуры другими зависимостями приложений. Использование контейнеров немыслимо без автоматизации, и именно этой цели служит Kubernetes.

**Базовая основа Kubernetes**

Все сущее в Kubernetes определяется в виде простых текстовых файлов в формате YAML или JSON, и платформа запускает образы OCI декларативным способом. Kubernetes позволяет определить желаемое состоя- ние всех приложений в кластере, их подключение к сети, место работы, используемое хранилище и т. д., делегируя базовую реализацию этих деталей самой платформе Kubernetes.

Традиционные правила инфраструктуры:
- конфигурация портов или IP-маршрутов;
- постоянная доступность хранилища для приложений;
- размещение программного обеспечения на определенных или произвольных серверах;
- обеспечение безопасного доступа приложений друг к другу с использованием, например, RBAC или сетевых правил;
- конфигурация DNS для каждого приложения и глобально.

Все эти компоненты определяются в конфигурационных файлах, представляющих объекты в Kubernetes API. Kubernetes использует эти стандартные блоки и контейнеры, применяет изменения, отслеживает эти изменения и устраняет сбои или нарушения, пока не будет достигнуто желаемое конечное состояние.

**Возможности Kubernetes**

Платформы оркестрации контейнеров позволяют разработчикам автоматизировать процесс запуска экземпляров, подготовки хостов, связывания контейнеров для оптимизации процедур оркестрации и продления жизненных циклов приложений. 

Основные возможности платформы оркестрации контейнеров:
- предоставления доступа, не зависящего от используемой облачной технологии, ко всем возможностям сервера API;
- интеграции со всеми основными облачными платформами и гипервизорами в диспетчере контроллеров Kubernetes (Kubernetes Controller Manager, KCM);
- обеспечения отказоустойчивости для хранения и определения состояния всех сервисов, приложений и конфигураций центров обработки данных или других инфраструктур, поддерживаемых Kubernetes;
- управления развертыванием, чтобы минимизировать время простоя отдельных узлов, сервисов или приложений;
- автоматизации масштабирования хостов и приложений с поддержкой постоянного обновления;
- создания внутренних и внешних соединений (известных как типы ClusterIP, NodePort или LoadBalancer Service) с балансировкой нагрузки;
- предоставления возможности планирования запуска приложе- ний на определенном виртуализированном оборудовании на основе его метаданных с помощью маркировки узлов и планировщика Kubernetes;
- обеспечения высокой доступности с помощью DaemonSets и других технологических инфраструктур, в которых приоритет
отдается контейнерам, работающим на всех узлах кластера;
- обнаружения сервисов через службу доменных имен, ранее реализованную как KubeDNS, а совсем недавно – CoreDNS, которая интегрируется с сервером API;
- запуска пакетных процессов (известных как задания), которые используют хранилище и контейнеры так же, как обычные приложения;
- расширения API и создания собственных программ, управляемых API, с помощью пользовательских определений ресурсов и без создания каких-либо сопоставлений портов или подключений;
- проверки сбойных процессов на уровне кластера, включая удаленное выполнение в любом контейнере в любое время с помощью kubectl exec и kubectl describe;
- подключения локального и/или удаленного хранилища к контейнеру и декларативного управления томами хранилища с помощью StorageClass API и PersistentVolumes.

Если вам не нужны высокая доступность, масштабируемость и оркестрация, то, возможно, вам не нужна Kubernetes.

**Компоненты и архитектура Kubernetes**
- аппаратная инфраструктура – включает компьютеры, сетевую инфраструктуру, инфраструктуру хранения и реестр контейнеров;
- рабочие узлы Kubernetes – базовая вычислительная единица в кластере Kubernetes;
- плоскость управления Kubernetes – основа Kubernetes. Она включает сервер API, планировщика, диспетчера контроллеров и другие контроллеры.

**Kubernetes API**

Администрирование микросервисов и других контейнерных приложений на платформе Kubernetes сводится к объявлению объектов Kubernetes API. Сервер Kubernetes API – kube-apiserver – позволяет выполнять CRUD-операции (Create, Read, Update, Delete – создавать, читать, обновлять, удалять) со всеми объектами и предоставляет интерфейс передачи репрезентативного состояния RESTful (REpresentational State Transfer).

Все объекты Kubernetes API имеют:
- именованную версию API (например, v1 или rbac.authorization. k8s.io/v1);
- тип (например, kind: Deployment);
- раздел метаданных.

Существует около 70 различных типов API, просмотреть их командой **kubectl api-resources**.

**Когда не стоит использовать Kubernetes**
- высокопроизводительные вычисления (High-Performance Comput- ing, HPC) – контейнеры добавляют дополнительные сложности, а наличие нового уровня бьет по производительности.
- унаследованные приложения – некоторые приложения имеют требования к оборудованию, программному обеспечению и задержке, что затрудняет их контейнеризацию.
- миграция – реализации унаследованных систем могут быть на- столько жесткими, что их миграция в Kubernetes не дает особых преимуществ

# Зачем нужны модули Pod?

Pod – это наименьшая атомарная единица, которую можно развернуть в кластере Kubernetes. Определение Pod описывает модуль, способный включать несколько контейнеров, что позволяет Kubernetes создать несколько контейнеров на узле. Многие другие объекты Kubernetes API либо используют Pod напрямую, либо являются объектами API, поддерживающими Pod. Некоторые контроллеры Kubernetes высокого уровня запускают модули Pod и управляют ими.

**Что такое Pod?**

Pod – это модуль, содержащий один или несколько образов OCI, которые выполняются в контейнерах на одном узле кластера Kubernetes. Узел Kubernetes – это отдельная единица вычислительной инфраструктуры (сервер), на которой выполняется kubelet.
```yml
apiVersion: v1
kind: Pod
metadata:
spec:
  container:
    - name: busybox
      image: mycontainerregistry.io/foo
```
**kubectl create -f pod.yaml**

Команда kubectl – это двоичный выполняемый файл, реализующий интерфейс командной строки к серверу Kubernetes API.

**kubectl get po** - посмотреть Pod

**Пространства имен в Linux**

Пространства имен Linux – это функция ядра Linux, позволяющая разделять процессы. Pod имеет следующие пространства имен Linux:
- одно или несколько пространств имен PID;
- единое сетевое пространство имен;
- пространство имен IPC;
- пространство имен cgroup (управляющая группа);
- пространство имен mnt (монтирование);
- пространство имен user (ID пользователя).

Пространства имен Linux – это компоненты файловой системы ядра Linux, обеспечивающие базовую функциональность для получения образа и создания работающего контейнера.

**Kubernetes, инфраструктура и Pod**

Единица вычислительной мощности в Kubernetes представлена объектом узла Node. Некоторые требования к узлу:
-  сервер;
-  установленная операционная система (ОС), Linux или Windows, с необходимыми зависимостями;
- systemd (диспетчер системных служб, в Linux);
- kubelet (агент узла);
- среда выполнения контейнеров (например, Docker);
- сетевой прокси-сервер (kube-proxy), обслуживающий сервисы Kubernetes;
- провайдер сетевого интерфейса контейнеров (Container Network Interface, CNI).

**kubelet** – это двоичная программа, играющая роль агента и взаимодействующая с сервером Kubernetes API посредством поддержки цикла управления. Она работает на каждом узле; без этой программы узел Kubernetes недоступен планировщику и не может считаться частью кластера.

kubelet гарантирует:
- запуск любых модулей Pod, запланированных для выполнения на данном хосте механизмом управления, который следит за распределением модулей Pod между узлами;
- регулярное уведомление сервера API об исправной работе kubelet отправкой контрольных сообщений (Kubernetes 1.17+) с помощью механизма в пространстве имен kube-node-lease кластера;
- своевременное освобождение ресурсов, выделенных для Pod, включая эфемерные хранилища или сетевые устройства.

**kubelet не может выполнять свои обязанности без провайдера CNI и среды выполнения**, доступной через интерфейс среды выполнения контейнеров (Container Runtime Interface, CRI). CNI обслуживает потребности CRI, который затем запускает и останавливает контейнеры. **kubelet использует CRI и CNI для согласования состояния узла с состоянием плоскости управления**.

**Сервис (Service)** – это объект API, определяемый платформой Kubernetes. Двоичный файл сетевого прокси Kubernetes (kube-proxy) создает на каждом узле сервисы ClusterIP и NodePort. Вот некоторые типы сервисов:
- ClusterIP – внутренний балансировщик, распределяющий нагрузку между модулями Pod в кластере Kubernetes;
- NodePort – открытый порт на узле Kubernetes, распределяющий нагрузку между несколькими модулями Pod;
- LoadBalancer – внешний сервис, создающий балансировщик нагрузки, внешний по отношению к кластеру.

**Объект Node**

Узлы поддерживают модули Pod, а плоскость управления определяет группу узлов, на которых работают контроллеры, диспетчер контроллеров и планировщик. Получить список узлов кластера - **kubectl get no**

Объект Node, описывающий узел, где размещена плоскость управления Kubernetes - **kubectl get no kind-control-plane -o yaml**

Модули Pod реализуют возможность развертывания образов. Образы развертываются на узле, а их жизненным циклом управляет kubelet. Объекты сервисов управляются сетевым прокси Kubernetes. Сетевой прокси Kubernetes обеспечивает возможность балансировки нагрузки внутри кластера, а также аварийное переключение, обновление, высокую доступность и масштабирование. Комбинация из пространства имен mnt в Linux, агента kubelet и объекта узла Node позволяет подключить диск к Pod.

### Сервер Kubernetes API: kube-apiserver

Сервер Kubernetes API (kube-apiserver) – это HTTP REST-сервер, экспортирующий различные объекты API для кластера Kubernetes, такие как Pod, Node или HorizontalPodAutoscaler. Сервер API предоставляет веб-интерфейс для выполнения операций CRUD с состоянием кластера. Сервер API – единственный компонент в плоскости управления, взаимодействующий с etcd, базой данных Kubernetes. По сути, сервер API предоставляет интерфейс для всех операций, изменяющих состояние кластера Kubernetes. Сервер API не имеет состояния и может работать на нескольких узлах одновременно. Перед серверами API в плоскости управления, состоящей из нескольких узлов, размещается балансировщик нагрузки HTTPS. В состав сервера API вхо- дят контроллеры доступа, обеспечивающие аутентификацию и авторизацию клиентов. Вызов, отправленный командой kubectl, проходит аутентификацию, а затем сервер API сохраняет новый объект развертывания в etcd. Следующий шаг – уведомление планировщика о необходимости запустить модуль Pod на узле.

### Планировщик Kubernetes: kube-scheduler




